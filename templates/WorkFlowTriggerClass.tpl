<?php
/**
 * Generated by GenerateWorkFlowTriggerClasses.php
 */
namespace PHPWorkFlow;

/**
 * Class {$triggerClass}
 */
class {$triggerClass} extends TriggerBase{

    /**
     * @param  $workItemObj
     *
     */
    public function __construct($workItemObj=null){
        parent::__construct($workItemObj);
    }

    /*
     * Each of these _trigger methods match a Transition in the workflow xxxxx where this class
     * is named Triggerxxxxx
     *
     * These trigger methods are called in 2 contexts
     *      @todo fix this
     *      - by a WorkFlowTrafficker that was generated by the app. In this case, we will check
     *          against the context data contained in the Tokens that point into
     *          the work_item in question
     *      - by a batch process or at work_item creating time to see if this work_item has been satisfied. In this case,
     *          $controllerResultsArr will be null and we'll need to cleverly access info via DAOS or whatever
     */

{foreach from=$triggerClassArr item=triggerinfo name=triggerinfoLoop}

    /**
     * @return bool
     * @throws Exception_WorkFlow
     */
    public function {$triggerinfo.triggerName}(){

    {if $triggerinfo.transitionType eq 'user'}

        /**
         * replace this with your CUSTOM CODE. Simply return false if the circumstances that 'pass' this
         * transition are not present OR
         * call $this->pullTheTrigger() and return true if they are present.
         */

        /** BEGIN CUSTOM CODE */

        /** lets see if a FREE TriggerFulfillment exists for {$triggerinfo.triggerName} */
        if ($this->getTriggerFulfillmentUtil()->FetchTriggerFulfillmentArrWithUseCaseIdAndTransitionIdAndTriggerFulfillmentStatus(
            $this->workItemObj->getUseCaseId(),
            $this->workItemObj->getTransitionId(),
            Enum\TriggerFulfillmentStatusEnum::FREE
        )){

            /*
             * Consume/drop tokens as warranted
             */
            if(Configuration_WorkFlow::getLogTriggerActivity()) {
                Logger_WorkFlow::info(
                    'Trigger passed. Type:{$triggerinfo.transitionType} Name:{$triggerinfo.triggerName} UseCase:'.$this->workItemObj->getUseCase()->getName().
                        ' use_case_id:'.$this->workItemObj->getUseCaseId(). 'at '.__FILE__.':'.__LINE__,
                    Logger_WorkFlow::LOGGER_WORKFLOW_TRIGGER
                );
            }
            $this->pullTheTrigger();
            return true;
        }
        else{
            if(Configuration_WorkFlow::getLogTriggerActivity()) {
                Logger_WorkFlow::info(
                    'Trigger failed. Type:{$triggerinfo.transitionType} Name:{$triggerinfo.triggerName} UseCase:'.$this->workItemObj->getUseCase()->getName().
                        ' use_case_id:'.$this->workItemObj->getUseCaseId(). 'at '.__FILE__.':'.__LINE__,
                    Logger_WorkFlow::LOGGER_WORKFLOW_TRIGGER
                );
            }
            return false;
        }
        /** END CUSTOM CODE */

    {elseif $triggerinfo.transitionType eq 'timed'}

        $whenToTriggerAfter = $this->workItemObj->getCreatedAt()->getTimestamp()  + $this->workItemObj->getTransition()->getTimeDelay();
        if($whenToTriggerAfter < time()){
            /**
             * add the CUSTOM CODE you want to run {$triggerinfo.time_delay} seconds
             * after this workItem is created. This trigger will run when the workItem in question is created
             * and (as long as the workItem in question is created is ENABLED) when
             * is run on the workItem in question. See scripts/pushUseCasesForward.php
             */
            /** BEGIN CUSTOM CODE */




            /** END CUSTOM CODE */
            /*
             * Consume/drop tokens as warranted
             */
            if(Configuration_WorkFlow::getLogTriggerActivity()) {
                Logger_WorkFlow::info(
                    'Trigger passed. Type:{$triggerinfo.transitionType} Name:{$triggerinfo.triggerName} UseCase:'.$this->workItemObj->getUseCase()->getName().
                        ' use_case_id:'.$this->workItemObj->getUseCaseId(). 'at '.__FILE__.':'.__LINE__,
                    Logger_WorkFlow::LOGGER_WORKFLOW_TRIGGER
                );
            }
            $this->pullTheTrigger();
            return true;
        }
        else{
            if(Configuration_WorkFlow::getLogTriggerActivity()) {
                Logger_WorkFlow::info(
                    'Trigger failed. Type:{$triggerinfo.transitionType} Name:{$triggerinfo.triggerName} UseCase:'.$this->workItemObj->getUseCase()->getName().
                        ' use_case_id:'.$this->workItemObj->getUseCaseId(). 'at '.__FILE__.':'.__LINE__,
                    Logger_WorkFlow::LOGGER_WORKFLOW_TRIGGER
                );
            }
            return false;
        }

    {elseif $triggerinfo.transitionType eq 'auto'}

        /**
         * insert CUSTOM CODE you want to run BEFORE the commands (if any) that were indicated in PNML file.
         * Remember returning false is not an option here unless you want this trigger to run over and over again.
         *
         */
        /** BEGIN CUSTOM CODE */



        /** END CUSTOM CODE */

        if($this->workItemObj->getTransition()->getCommands()){
            foreach($this->workItemObj->getTransition()->getCommands() as $commandObj){
                $matches = [];
                $param_value_pairs = [];
                if(preg_match_all("/%([A-z1-9_]*)($|\s)/", $commandObj->getCommandString(), $matches)){
                    foreach($matches[1] as $match){
                        if($useCaseTokenObj = $this->getWorkFlowDAO()->FetchUseCaseContextArrWithUseCaseIdAndName($this->workItemObj->getUseCaseId(), $match)){
                            $param_value_pairs[$match] = $useCaseTokenObj->getValue();
                        }
                    }
                }

                $command_string =  $commandObj->getCommandString();
                foreach($param_value_pairs as $key => $value){
                    $command_string = preg_replace('/%' . $key.'/', $value, $command_string);
                }
                /**
                 * @todo add system call here
                 */

            }
        }
        /**
         * insert CUSTOM CODE you want to run AFTER the commands (if any) that were indicated in PNML file.
         * Remember returning false is not an option here unless you want this trigger to run over and over again.
         *
         */
        /** BEGIN CUSTOM CODE */



        /** END CUSTOM CODE */

        /*
         * Consume/drop tokens
         */
        if(Configuration_WorkFlow::getLogTriggerActivity()) {
            Logger_WorkFlow::info(
                'Trigger passed. Type:{$triggerinfo.transitionType} Name:{$triggerinfo.triggerName} UseCase:'.$this->workItemObj->getUseCase()->getName().
                    ' use_case_id:'.$this->workItemObj->getUseCaseId(). 'at '.__FILE__.':'.__LINE__,
                Logger_WorkFlow::LOGGER_WORKFLOW_TRIGGER
            );
        }

        /**
        * unconditionally pull trigger and return true
        */
        $this->pullTheTrigger();
        return true;

    {elseif $triggerinfo.transitionType eq 'notification'}

        /**
         * insert code you want to run when this workItem is created Returning
         * false is not an option here
         */
        foreach($this->workItemObj->getTransition()->getNotifications() as $notificationObj){
            if($notificationObj->getNotificationType() == Enum\NotificationTypeEnum::EMAIL){

                /**
                 * email somebody something using $notificationObj->getNotificationString()
                 */
                /** BEGIN CUSTOM CODE */

                /** END CUSTOM CODE */
            }
            elseif($notificationObj->getNotificationType() == Enum\NotificationTypeEnum::SMS){
                /**
                 * sms somebody something using $notificationObj->getNotificationString()
                 */
                /** BEGIN CUSTOM CODE */

                /** END CUSTOM CODE */
            }
        }
        /**
         * Consume/drop tokens
         */
        if(Configuration_WorkFlow::getLogTriggerActivity()) {
            Logger_WorkFlow::info(
                'Trigger passed. Type:{$triggerinfo.transitionType} Name:{$triggerinfo.triggerName} UseCase:'.$this->workItemObj->getUseCase()->getName().
                    ' use_case_id:'.$this->workItemObj->getUseCaseId(). 'at '.__FILE__.':'.__LINE__,
                Logger_WorkFlow::LOGGER_WORKFLOW_TRIGGER
            );
        }
        /**
        * unconditionally pull trigger and return true
        */
        $this->pullTheTrigger();
        return true;

    {elseif $triggerinfo.transitionType eq 'gate'}

        $trigger_derived_value = false;
        $work_items_to_trigger = [];

        /**
         * replace this if stmt with your code that calculates the
         * $trigger_derived_value we compare to
         * the gates for this workitem's transition.Returning
         * false is not an option here
         */
        /** BEGIN CUSTOM CODE */

        /** lets see if a FREE TriggerFulfillment exists for {$triggerinfo.triggerName} */
        if ($this->getTriggerFulfillmentUtil()->FetchTriggerFulfillmentArrWithUseCaseIdAndTransitionIdAndTriggerFulfillmentStatus(
            $this->workItemObj->getUseCaseId(),
            $this->workItemObj->getTransitionId(),
            Enum\TriggerFulfillmentStatusEnum::FREE
        )){
            $trigger_derived_value = true;
        }

        /** END CUSTOM CODE */

        /**
         * Now that $trigger_derived_value is populated, let's check it
         */

        foreach($this->workItemObj->getTransition()->getGates() as $gateObj)
        {
            if($gateObj->getValueTyped() === $trigger_derived_value)
            {
                $work_items_to_trigger[] = $this->getWorkFlowDAO()->FetchTransitionWithWorkFlowIdAndYasperName(
                    $this->workItemObj->getUseCase()->getWorkFlowId(),
                    $gateObj->getTargetYasperName()
                )->getTransitionId();
            }
        }
        if(! $work_items_to_trigger)
        {
            throw new Exception_WorkFlow('Invalid gate');
        }
        /**
         * Consume/drop tokens
         */
        if(Configuration_WorkFlow::getLogTriggerActivity()) {
            Logger_WorkFlow::info(
                'Trigger passed. Type:{$triggerinfo.transitionType} Name:{$triggerinfo.triggerName} UseCase:'.$this->workItemObj->getUseCase()->getName().
                    ' use_case_id:'.$this->workItemObj->getUseCaseId(). 'at '.__FILE__.':'.__LINE__.
                    'trigger_derived_value = '. $trigger_derived_value,
                Logger_WorkFlow::LOGGER_WORKFLOW_TRIGGER
            );
        }
        /**
        * unconditionally pull trigger and return true
        */
        $this->pullTheTriggerOnGate($work_items_to_trigger);
        return true;

    {else}

        # unknown transitionType

    {/if}

    }
{/foreach}
}